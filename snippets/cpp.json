{
    "fenwick": {
        "prefix": "fenwick",
        "body": [
            "// range update, point query",
            "class fenwick {",
            "    vector<int> tree;",
            "    int n;",
            "    // 1-based indexing",
            "public:",
            "    void init(vector<int>& arr) {",
            "        n = arr.size();",
            "        tree.assign(n+1, 0);",
            "        foi(1,n+1) update(i, arr[i-1]);",
            "    }",
            "    void init(int x) {",
            "        n = x;",
            "        tree.assign(n+1, 0);",
            "    }",
            "    int sum(int i) // returns value at an index",
            "    { // time comp O(logn)",
            "        int ans = 0;",
            "        for (; i > 0; i -= (i & (-i))) {",
            "            ans += tree[i];",
            "        }",
            "        return ans;",
            "    }",
            "    void update(int i, int x) // adds x at an index",
            "    {",
            "        for (; i <= n; i += (i & (-i))) {",
            "            tree[i] += x;",
            "        }",
            "    }",
            "    void range_update(int l, int r, int x) { // adds x to indices l, l+1,..., r",
            "        update(l, x), update(r+1, -x);",
            "    }",
            "};"
        ],
        "description": "Fenwick Tree: range update, point query"
    },
    "nck": {
        "prefix": "nck",
        "body": [
            "vector<int> fact(300000);",
            "void pre()",
            "{",
            "    fact[0] = 1;",
            "    fact[1] = 1;",
            "    foi(2, 300000)",
            "    {",
            "        fact[i] = (fact[i - 1] * i) % mod;",
            "    }",
            "}",
            "",
            "int powmod(int a, int b, int p)",
            "{",
            "    a %= p;",
            "    if (a == 0)",
            "        return 0;",
            "    int product = 1;",
            "    while (b > 0) {",
            "        if (b & 1) { // you can also use b % 2 == 1",
            "            product *= a;",
            "            product %= p;",
            "            --b;",
            "        }",
            "        a *= a;",
            "        a %= p;",
            "        b /= 2; // you can also use b >> 1",
            "    }",
            "    return product;",
            "}",
            "int inv(int a, int p)",
            "{",
            "    return powmod(a, p - 2, p);",
            "}",
            "int nCk(int n, int k, int p)",
            "{",
            "    return ((fact[n] * inv(fact[k], p) % p) * inv(fact[n - k], p)) % p;",
            "}"
        ],
        "description": "nCk"
    },
    "powmod": {
        "prefix": "powmod",
        "body": [
            "int powmod(int a, int b, int p)",
            "{",
            "    a %= p;",
            "    if (a == 0)",
            "        return 0;",
            "    int product = 1;",
            "    while (b > 0) {",
            "        if (b & 1) { // you can also use b % 2 == 1",
            "            product *= a;",
            "            product %= p;",
            "            --b;",
            "        }",
            "        a *= a;",
            "        a %= p;",
            "        b /= 2; // you can also use b >> 1",
            "    }",
            "    return product;",
            "}"
        ],
        "description": "power with modulo"
    },
    "inverse":{
        "prefix":"inverse",
        "body":[
            "int powmod(int a, int b, int p)",
            "{",
            "    a %= p;",
            "    if (a == 0)",
            "        return 0;",
            "    int product = 1;",
            "    while (b > 0) {",
            "        if (b & 1) { // you can also use b % 2 == 1",
            "            product *= a;",
            "            product %= p;",
            "            --b;",
            "        }",
            "        a *= a;",
            "        a %= p;",
            "        b /= 2; // you can also use b >> 1",
            "    }",
            "    return product;",
            "}",
            "",
            "int inv(int a, int p)",
            "{",
            "    return powmod(a, p - 2, p);",
            "}"
        ],
        "description":"find inverse of a big number"
    }
}
